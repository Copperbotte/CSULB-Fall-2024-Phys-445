"""
# Joseph Kessler
# 2024 September 20
# wavebin_parser.py
################################################################################
#     This script reads binary files generated by Agilent, Keysight, and Rigol
# osciloscopes.
# It is a port of the following repo to operate as a python module:
# 
# https://github.com/sam210723/wavebin/blob/master/wavebin/wave.py#L67
# 
#     I am avoiding directly importing this repo in case I need to optimize data
# ingest performance later.
"""
# import wavebin

from lint import docstring
import numpy as np
import struct
from collections import namedtuple

# Parses an integer from an opened file with little endian byte order.
def readintLE(file, n):
    return int.from_bytes(file.read(n), byteorder='little')

# Parses the file metadata header.
def parse_file_header(file):
    # Read file magic and format version
    magic = file.read(2)
    version = int(file.read(2).decode('utf-8'))

    # Get vendor based on file magic
    vendor = {
        b'AG': "Agilent/Keysight",
        b'RG': "Rigol"
    }

    # Check file magic
    if not magic in vendor:
        raise Exception("Unknown file format")
    else:
        magic = vendor[magic]

    # Set unpack format for file version
    if version == 1 or version == 10:
        size, count = 4, 4
    elif version == 3:
        size, count = 8, 4
    else:
        raise Exception("Unknown file format")

    # Unpack file header
    file_header_tuple = namedtuple(
        "FileHeader",
        "magic version size waveforms"
    )
    file_header = file_header_tuple(
        magic, version, readintLE(file, size), readintLE(file, count)
    )
    
    return file_header

# Parses a waveform's metadata.
def parse_waveform_header(file):
    # Read data from file
    length = readintLE(file, 1)
    data = bytes([length]) + file.read(length - 1)

    # Unpack waveform header
    waveform_header_tuple = namedtuple(
        "WaveformHeader",
        "size wave_type buffers points average "\
        "x_d_range x_d_origin x_increment x_origin "\
        "x_units y_units date time frame label "\
        "time_tags segment"
    )
    fields = list(struct.unpack("5if3d2i16s16s24s16sdI", data))

    # Clean text fields
    for i in [11, 12, 13, 14]:
        fields[i] = fields[i].decode('utf-8').replace('\x00', '')
    
    return waveform_header_tuple(*fields)

# Parses a waveform's data header.
def parse_data_header(file, file_header):
    # Read data from file
    length = readintLE(file, 1)
    data = bytes([length]) + file.read(length - 1)

    # Unpack waveform data header
    waveform_data_header_tuple = namedtuple(
        "WaveformDataHeader",
        "size data_type bpp length"
    )
    if file_header.version == 1 or file_header.version == 10:
        fields = struct.unpack("i2hi", data)
    elif file_header.version == 3:
        fields = struct.unpack("i2hQ", data)

    return waveform_data_header_tuple(*fields)

# Parse the waveform's bulk data.
def parse_data(file, data_header):
    data = file.read(data_header.length)

    # Get waveform data type
    if data_header.data_type in [1, 2, 3]:
        data_type = np.float32
    elif data_header.data_type == 6:
        data_type = np.uint8
    else:
        data_type = np.float32

    # Parse buffer into numpy array
    return np.frombuffer(data, dtype=data_type)

# Parses the waveform binary file, returns a very verbose named tuple.
def parse_file(path):
    with open(path, 'rb') as file:
        file_header = parse_file_header(file)
        wave_headers, data_headers, data = [], [], []

        for i in range(file_header.waveforms):
            wave_header = parse_waveform_header(file)
            data_header = parse_data_header(file, file_header)
            wave_data = parse_data(file, data_header)

            wave_headers.append(wave_header)
            data_headers.append(data_header)
            data.append(wave_data)

    Waveform = namedtuple('Waveform',
        'path file_header wave_headers data_headers data')

    return Waveform(path, file_header, wave_headers, data_headers, data)

# Displays the waveform headers in a convinient format.
def debug_print_headers(Waveform):
    class preprint:
        def __init__(self):
            self.lines = []
        def rint(self, *args):
            self.lines.append(' '.join(map(str, args)))
        def __str__(self):
            return "\n".join(self.lines)
        def __enter__(self):
            return self
        def __exit__(self, *args):
            print(self)

    with preprint() as p:
        p.rint("-- File header --")
        for k,v in Waveform.file_header._asdict().items():
            p.rint('%s:'%k, v)
        p.rint()

        def lprint(*args):
            p.rint('|', *args)

        for n,(wave,data) in enumerate(zip(Waveform.wave_headers, Waveform.data_headers), 1):
            header = "Wave #%d"%n
            p.rint(header)
            lprint("-- Wave Header --")
            for k,v in wave._asdict().items():
                lprint('%s:'%k, v)
            lprint()

            lprint("-- Data header --")
            for k,v in data._asdict().items():
                lprint('%s:'%k, v)
            p.rint('-'*len(header))
            p.rint()

# Parses the waveform.  This is the one you want to use!
def parse(path, Print=False):
    Waveform = parse_file(path)

    if Print:
        debug_print_headers(Waveform)
    
    whead = Waveform.wave_headers[0]
    t = np.linspace(0, 1, num=whead.points, endpoint=False)
    t = t*whead.x_d_range + whead.x_d_origin

    data = np.empty((whead.points, Waveform.file_header.waveforms+1))
    data[:,0] = t
    for n,wave in enumerate(Waveform.data, 1):
        data[:,n] = wave

    return data
